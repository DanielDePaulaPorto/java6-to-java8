=== Objetos Strings

.Objetivo
----
Develop code that uses String objects in the switch statement, binary literals, and numeric literals, including underscores in literals

-

Desenvolver código que utilize objetos String em instruções Switch, binários literais, e numéricos literais, incluindo underscore (_) em literais
----

==== String em instruções Switch

É esperado que o candidato saiba compreender e analisar o uso de Strings em instruções `switch`, como no seguinte exemplo.

[source,java]
----
public static void main(String[] args) {
    
    String mes = "jan";
    
    switch (mes) {
    case "jan":
        System.out.println("Janeiro");
        break;
    case "fev":
        System.out.println("Fevereiro");
        break;
    case "mar":
        System.out.println("Março");
        break;
    default:
        break;
    }
}
----

Apesar da certificação ter foco nas atualizações trazidas pelo Java 7 e 8, é esperado que o candidato entenda também conceitos de versões anteriores do Java. Por isso, serão apresentadas algumas regras que talvez você já conheça sobre `switch`, mas utilizando `String` no `switch`.

. Todo `case` deve ser único, não pode se repetir.

. O `default` pode aparecer em qualquer posição no `switch`.
+
.exemplo
[source,java]
----
public static void main(String[] args) {
    
    String mes = "jan";
    
    switch (mes) {
    case "jan":
        System.out.println("Janeiro");
        break;
    default: # <1>
        break;
    case "jan": # <2>
        System.out.println("Janeiro2");
        break;
    case "mar":
        System.out.println("Março");
        break;
    }
}
----
<1> *COMPILA*: o default pode estar em qualquer posição
<2> *NÃO COMPILA*: já existe o case "jan"

. Tipos suportados em `switch`.
* int e Integer
* byte e Byte
* short e Short
* char e Character
* String
* valores de Enums

. Tipos não suportados em `switch`.
+
.exemplo
[source,java]
----
public static void main(String[] args) {
    
    Long mes = 1L;
    
    switch (mes) { // NÃO COMPILA - Long não é um tipo suportado
    case 1L:
        System.out.println("Janeiro");
        break;
    case 2L:
        System.out.println("Fevereiro");
        break;
    default:
        break;
        }
    
}
----

. A execução se inicia em um `case` e somente para ao encontrar um `break`.
+
.exemplo
[source,java]
----
public static void main(String[] args) {
    
    String mes = "jan";
    
    switch (mes) {
    case "jan":
        System.out.println("Janeiro");
    default:
        System.out.println("Não é um mês");
    case "fev":
        System.out.println("Fevereiro");
        break;
    case "mar":
        System.out.println("Março");
        break;
    }
}
----
+
.saída no console
[source,console]
----
Janeiro
Não é um mês
Fevereiro
----
+
Nesse caso a execução inicia no `case "jan"`, passar pelo `default` e pelo `case "fev"` até parar no `break`, por isso as 3 strings aparecem no console.

. Um `switch` vazio é válido, mesmo que não tenha utilidade.
+
.exemplo
[source,java]
----
public static void main(String[] args) {
    
    String mes = "jan";
    switch (mes) {} // COMPILA - switch pode estar vazio, mesmo que seja inútil
}
----

. Todos os valores de `case` precisam ser constantes, ou seja, variáveis finais em tempo de compilação. Se o valor do `case` puder mudar em tempo de execução, o código não compila.
+
.exemplo
[source,java]
----
public class StringInSwitch {

    private static final String FEV = "fev";
    private static String jan = "jan";
    
    public static void getNomeMes(final String mai) {
        
        String mes = "jan";
        
        final String mar = "mar";
        String abr = "abr";
        
        switch (mes) {
        case jan: // NÃO COMPILA - jan é um atributo comum, pode mudar em tempo de execução
            System.out.println("Janeiro");
            break;
        case FEV: // COMPILA - FEV é uma constante em tempo de compilação, seu valor nunca muda
            System.out.println("Fevereiro");
            break;
        case mar: // COMPILA - mar é uma constante em tempo de compilação, seu valor nunca muda
            System.out.println("Março");
            break;
        case abr: // NÃO COMPILA - abr é uma variável comum, pode mudar em tempo de execução
            System.out.println("Março");
            break;
        case mai: // NÃO COMPILA - mai é final, mas não é constante, pode mudar em tempo de execução
            System.out.println("Março");
            break;
         }
    }
}
----

Pronto, essas são as regras de `switch`. Você provavelmente já conheçe algumas referentes à versões anteriores do Java, mas agora você as viu em `switch` que utilizam Strings. Isso não era possível antes do Java 7.

==== Literais Binários e Numéricos, incluindo underscore( _ )

É esperado que o candidato saiba compreender e analisar o uso de literais binários e numéricos, como no seguinte exemplo.

[source,java]
----
int i1 = 1;             // int
int i2 = 1_000_000;     // int com underscore
int i3 = 0567;          // octadecimal
int i4 = 0xFA1;         // hexadecimal
int i5 = 0b0101;        // binário

long l1 = 1L;           // long com L
long l2 = 1l;           // long com l
long l3 = 12_345_6_7890_123456_789L; // long com underscore
long l4 = 0xFA1L;       // long hexadecimal

double d1 = 1.00;       // double
double d2 = 100_000.01; // double com underscore
double d3 = 1D;         // double com D

float f1 = 1.00F;       // float
----

Apesar da certificação ter foco nas atualizações trazidas pelo Java 7 e 8, é esperado que o candidato entenda também conceitos de versões anteriores do Java. Por isso, serão apresentadas algumas regras que talvez você já conheça sobre literais.

. No Java, _Literal_ é qualquer número escrito diretamente no código, como todos do exemplo acima. 

. Por padrão, o Java interpreta literais como `int`. Ou seja, se não houver um sufixo no número para mudar seu tipo, ele é um `int`.
+
.exemplo
[source,java]
----
int i1 = 1;       // por padrão é int
long l1 = 1L;     // com um L no final, é um long
double d1 = 1.0;
double d2 = 1.0D; // com ou sem D no final, se tiver casa decimal é um double por padrão
float f1 = 1.0F;  // com um F no final, é um float
----

. Por padrão, o Java interpreta literais como sendo decimais. Existem prefixos que mudam o sistema numérico do literal.
+
.exemplo
[source,java]
----
int i1 = 0567;    // octadecimal - base 8 - começa com 0
int i2 = 0xFA1;   // hexadecimal - base 16 - começa com 0x
int i3 = 0b0101;  // binário - base 2 - começa com 0b
long l1 = 0xABCL; // long também pode ser hexadecimal - começa com 0x e termina com L
----

. A partir do Java 7, é possível utilizar underscore (_) para separar visualmente um número. Isso não muda o valor do número, e serve apenas para tornar o código mais legível.
+
.exemplo
[source,java]
----
int i1 = 1_000_000; // int com underscore - é o mesmo que escrever 1000000
int i2 = 10_00_00_0; // o underscore pode estar em qualquer posição entre 2 números
int i3 = _1000; // NÃO COMPILA - o underscore não pode estar no início
int i4 = 1000_; // NÃO COMPILA - o underscore não pode estar no final

long l3 = 12_345_6_7890_123456_789L; // long com underscore

double d2 = 100_000.01; // double com underscore
double d2 = 10_.01; // NÃO COMPILA - o underscore deve estar entre números
double d2 = 10._01; // NÃO COMPILA - o underscore deve estar entre números
----
